// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>
#include <curl/curl.h>
#include <string>
#include "rpc.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "cache.h"
#include <signal.h>
#include <time.h>

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::tutorial;

static int number_of_accesses;
static int number_of_hits;
static double total_time;


static size_t
WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
 
  // contents is a pointer to the chunk of data received 
  size_t realsize = size * nmemb;  	  //size of the data received is (size * nmemb)
  string *data = (string *)userp;   	  //custom pointer to the entire data that you are going to receive
  string data_segment = (char *)contents;  
  (*data).append(data_segment);           //appending the data chunk just received to obtain the entire data 
  return realsize;
}

class rpcHandler : virtual public rpcIf {
 public:
  rpcHandler(const string& cache_policy, size_t cache_size) {
    // Your initialization goes here
	size_t max_capacity = cache_size*1024; //in KB
	size_t min_entry_size = 1024;  //1KB
	number_of_accesses = 0;
	number_of_hits = 0;
	cache_init(max_capacity, min_entry_size, cache_policy);
  }

  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param url
   */
  void get_data(std::string& _return, const std::string& url) 
  {
	string data = "";

    //incrementing the number of times the access to a webpage happens
	number_of_accesses = number_of_accesses + 1;

    //for access time measurements
 	time_t begin_time, end_time;
    
    //start time
	time(&begin_time);

    //checking if the page is the cache
	cache_get(url,data);

	if(!data.empty())
	{    
		//page found in the cache, it is a hit ! So increment number of hits
		number_of_hits = number_of_hits + 1; 
	}
	else
	{

		//if page not found, use cURL to obtain it

		CURL *curl_handle;
		CURLcode res;
   
		curl_global_init(CURL_GLOBAL_ALL);  //Should be done once for the program's entire lifetime
 
		/* init the curl session */ 
		curl_handle = curl_easy_init();
 	
		/* specify URL to get */ 
		curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());
 
		/* send all data to this function  */ 
		curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
 	
		curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&data);

		/* some servers don't like requests that are made without a user-agent field, so we provide one */ 
		curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");
 
		/* get it! */ 
		res = curl_easy_perform(curl_handle);
		
		/* check for errors */ 
		if(res != CURLE_OK) 
		{
			fprintf(stderr, "curl_easy_perform() failed: %s\n",
			curl_easy_strerror(res));
		}
 	
  		/* cleanup curl stuff */ 
  		curl_easy_cleanup(curl_handle);
 
  		/* we're done with libcurl, so clean it up */ 
  		curl_global_cleanup();  //cleanup the resources the curl_global_init call initialized
	
		cache_set(url,data);
	}

   	//end time
	time(&end_time);

	//total time for access (either to the cache or to actually obtain the page from the internet)
	total_time = total_time + difftime(end_time,begin_time);
	_return = data;  
  }

  void print_statistics(Stats& _return) 
  {  
     //calculating statistics
    _return.hit_ratio = (double)number_of_hits/(double)number_of_accesses;
    _return.time_taken = total_time/number_of_accesses;
  }

};

int main(int argc, char **argv) {
  int port = 9090;

  shared_ptr<rpcHandler> handler(new rpcHandler(argv[1],atoi(argv[2])));
  //argv[1] = cache type (either lru or maxs or rnd)
  //argv[2] = cache size in KB

  shared_ptr<TProcessor> processor(new rpcProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}
